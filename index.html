<!-- Reid Was the first to ever reach 1000--->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GTA-Lite (Anti Spawn-Camp Demo)</title>
<style>
  html, body { margin:0; height:100%; background:#0e0e12; color:#eaeaf0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
  #hud { position:fixed; top:10px; left:10px; background:#121421cc; border:1px solid #26293a; border-radius:12px; padding:8px 12px; }
  #hud .row { display:flex; gap:12px; align-items:center; }
  #hud .pill { padding:3px 8px; border-radius:999px; border:1px solid #26293a; background:#0f1120; color:#b7bdde; }
  #hud strong { color:#f6f7ff; }
  canvas { display:block; margin:0 auto; background:#0b0d18; border-left:1px solid #26293a; border-right:1px solid #26293a; }
</style>
</head>
<body>
<div id="hud">
  <div class="row">
    <span class="pill">WASD: move</span>
    <span class="pill">Shift: sprint</span>
    <span class="pill">R: force respawn (test)</span>
  </div>
  <div style="margin-top:6px">
    <strong>Wanted:</strong> <span id="wanted">Yes</span> •
    <strong>Health:</strong> <span id="hp">100</span> •
    <strong>Cops:</strong> <span id="copCount">0</span>
  </div>
</div>

<canvas id="game" width="960" height="600"></canvas>

<script>
/* =========================
   === Config Tunables  ===
   ========================= */
const MAP_W = 2000, MAP_H = 1400;
const PLAYER_RADIUS = 14;
const COP_RADIUS = 12;

const WALK_SPEED = 180;   // px/s
const SPRINT_SPEED = 260; // px/s
const COP_SPEED = 120;    // px/s

const DAMAGE_PER_HIT = 17;
const TOUCH_RANGE = PLAYER_RADIUS + COP_RADIUS - 2;

const SPAWN_PROTECTION_MS = 3000; // grace window
const SAFE_RADIUS = 180;          // keep cops outside this while protected
const MIN_SAFE_SPAWN = 200;       // preferred min distance of nearest cop
const COP_SPAWN_COOLDOWN_MS = 900; // how often a new cop can spawn

/* =========================
   === Utility helpers   ===
   ========================= */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rand = (a,b) => a + Math.random()*(b-a);
const dist = (a,b) => Math.hypot(a.x - b.x, a.y - b.y);

// Uniform random position on the map
function randPos() { return { x: rand(40, MAP_W-40), y: rand(40, MAP_H-40) }; }

/* =========================
   === World / Entities  ===
   ========================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const keys = new Set();

const player = {
  pos: { x: 400, y: 300 },
  vel: { x: 0, y: 0 },
  hp: 100,
  invulnerableUntil: 0,
  spawnSafeUntil: 0,
  uiCountdownEnd: 0
};

const cops = [];
let lastCopSpawnAt = 0;

// A few fixed spawn points spread around the map
const spawnPoints = [
  {x: 200,  y: 220},
  {x: 1720, y: 260},
  {x: 480,  y: 1200},
  {x: 1480, y: 1040},
  {x: 980,  y: 700},
  {x: 260,  y: 980}
];

/* =========================
   === Anti Spawn-Camp   ===
   ========================= */
function chooseSafeSpawn(spawnPoints, cops, minSafe = MIN_SAFE_SPAWN) {
  const shuffled = spawnPoints.slice().sort(() => Math.random() - 0.5);

  // First pass: any spawn that is >= minSafe from *every* cop
  for (const p of shuffled) {
    if (cops.every(c => dist(p, c.pos) >= minSafe)) return { x: p.x, y: p.y };
  }

  // Fallback: maximize nearest-cop distance
  let best = shuffled[0], bestScore = -Infinity;
  for (const p of shuffled) {
    const nearest = cops.reduce((m,c)=> Math.min(m, dist(p, c.pos)), Infinity);
    if (nearest > bestScore) { bestScore = nearest; best = p; }
  }
  return { x: best.x, y: best.y };
}

function startSpawnProtection(p) {
  const end = performance.now() + SPAWN_PROTECTION_MS;
  p.invulnerableUntil = end;
  p.spawnSafeUntil = end;
  p.uiCountdownEnd = end; // for 3-2-1-GO
}

function canDamagePlayer(p) {
  return performance.now() > (p.invulnerableUntil || 0);
}

function copShouldTargetPlayer(p) {
  const now = performance.now();
  if (now <= (p.spawnSafeUntil || 0)) return false; // ignore during grace
  return true;
}

function enforceNoCopZone(p, cops) {
  const now = performance.now();
  if (now > (p.spawnSafeUntil || 0)) return;

  for (const cop of cops) {
    const d = dist(p.pos, cop.pos);
    if (d < SAFE_RADIUS) {
      const dx = cop.pos.x - p.pos.x;
      const dy = cop.pos.y - p.pos.y;
      const n = Math.hypot(dx,dy) || 1;
      const k = (SAFE_RADIUS - d) + 1;  // push to edge
      cop.pos.x += (dx / n) * k;
      cop.pos.y += (dy / n) * k;
      if (cop.vel) { cop.vel.x = 0; cop.vel.y = 0; }
      cop.nextThinkAt = Math.max(cop.nextThinkAt || 0, now + 250);
    }
  }
}

function spawnCopAvoidingPlayer(suggestedPos, player) {
  const p = { x: suggestedPos.x, y: suggestedPos.y };
  const d = dist(p, player.pos);
  if (d < SAFE_RADIUS + 80) {
    // move it to the ring outside the safe bubble
    let dx = p.x - player.pos.x; if (!dx) dx = 1;
    let dy = p.y - player.pos.y; if (!dy) dy = 0.4;
    const n = Math.hypot(dx,dy);
    const newD = SAFE_RADIUS + 140;
    p.x = clamp(player.pos.x + (dx / n) * newD, 20, MAP_W-20);
    p.y = clamp(player.pos.y + (dy / n) * newD, 20, MAP_H-20);
  }
  cops.push({ pos: p, vel: {x:0,y:0}, nextThinkAt: 0 });
}

function respawnPlayer() {
  const spot = chooseSafeSpawn(spawnPoints, cops, MIN_SAFE_SPAWN);
  player.pos.x = spot.x;
  player.pos.y = spot.y;
  player.vel.x = 0; player.vel.y = 0;
  player.hp = 100;
  startSpawnProtection(player);
  // Instantly “wanted” (your rule), but protected
  // (HUD already shows "Wanted: Yes")
}

/* =========================
   === Input handling    ===
   ========================= */
addEventListener('keydown', (e)=> {
  keys.add(e.key.toLowerCase());
  if (e.key.toLowerCase() === 'r') { // quick test respawn
    respawnPlayer();
  }
});
addEventListener('keyup',   (e)=> keys.delete(e.key.toLowerCase()) );

/* =========================
   === Game update loop  ===
   ========================= */
let last = performance.now();

function update(dt) {
  // Player move
  const up = keys.has('w'), down = keys.has('s'), left = keys.has('a'), right = keys.has('d');
  const sprint = keys.has('shift');

  let vx = 0, vy = 0;
  if (up) vy -= 1;
  if (down) vy += 1;
  if (left) vx -= 1;
  if (right) vx += 1;
  const n = Math.hypot(vx, vy);
  const speed = sprint ? SPRINT_SPEED : WALK_SPEED;
  if (n) {
    player.vel.x = (vx / n) * speed;
    player.vel.y = (vy / n) * speed;
  } else {
    player.vel.x = 0; player.vel.y = 0;
  }
  player.pos.x = clamp(player.pos.x + player.vel.x * dt, PLAYER_RADIUS, MAP_W - PLAYER_RADIUS);
  player.pos.y = clamp(player.pos.y + player.vel.y * dt, PLAYER_RADIUS, MAP_H - PLAYER_RADIUS);

  // Cop AI (simple seek)
  const now = performance.now();
  for (const cop of cops) {
    if (cop.nextThinkAt && now < cop.nextThinkAt) continue;

    if (copShouldTargetPlayer(player)) {
      const dx = player.pos.x - cop.pos.x;
      const dy = player.pos.y - cop.pos.y;
      const d = Math.hypot(dx,dy) || 1;
      cop.vel.x = (dx/d) * COP_SPEED;
      cop.vel.y = (dy/d) * COP_SPEED;
    } else {
      // Loiter while player protected
      cop.vel.x = 0; cop.vel.y = 0;
    }
  }

  // Cop move + clamp
  for (const cop of cops) {
    cop.pos.x = clamp(cop.pos.x + cop.vel.x * dt, COP_RADIUS, MAP_W - COP_RADIUS);
    cop.pos.y = clamp(cop.pos.y + cop.vel.y * dt, COP_RADIUS, MAP_H - COP_RADIUS);
  }

  // Enforce safe bubble during protection
  enforceNoCopZone(player, cops);

  // Collisions (damage)
  if (canDamagePlayer(player)) {
    for (const cop of cops) {
      if (dist(player.pos, cop.pos) <= TOUCH_RANGE) {
        player.hp = Math.max(0, player.hp - DAMAGE_PER_HIT);
        // small knock-back
        const dx = player.pos.x - cop.pos.x, dy = player.pos.y - cop.pos.y;
        const nn = Math.hypot(dx,dy) || 1;
        player.pos.x = clamp(player.pos.x + (dx/nn)*8, PLAYER_RADIUS, MAP_W - PLAYER_RADIUS);
        player.pos.y = clamp(player.pos.y + (dy/nn)*8, PLAYER_RADIUS, MAP_H - PLAYER_RADIUS);
      }
    }
  }

  // Death -> respawn safely
  if (player.hp <= 0) {
    respawnPlayer();
  }

  // Spawn more cops over time (not inside safe bubble)
  if (now - lastCopSpawnAt > COP_SPAWN_COOLDOWN_MS && cops.length < 12) {
    const edge = Math.floor(rand(0,4)); // spawn from edges to feel fair
    let p;
    if (edge === 0)      p = { x: rand(20, MAP_W-20), y: 20 };
    else if (edge === 1) p = { x: rand(20, MAP_W-20), y: MAP_H-20 };
    else if (edge === 2) p = { x: 20, y: rand(20, MAP_H-20) };
    else                 p = { x: MAP_W-20, y: rand(20, MAP_H-20) };
    spawnCopAvoidingPlayer(p, player);
    lastCopSpawnAt = now;
  }

  // HUD
  document.getElementById('hp').textContent = player.hp.toString();
  document.getElementById('copCount').textContent = cops.length.toString();
  document.getElementById('wanted').textContent = "Yes";
}

/* =========================
   === Rendering         ===
   ========================= */
function render() {
  // Camera follows player (simple)
  const viewW = canvas.width, viewH = canvas.height;
  const camX = clamp(player.pos.x - viewW/2, 0, MAP_W - viewW);
  const camY = clamp(player.pos.y - viewH/2, 0, MAP_H - viewH);

  ctx.save();
  ctx.clearRect(0,0,viewW,viewH);
  ctx.translate(-camX, -camY);

  // Draw map grid
  ctx.fillStyle = "#0b0d18";
  ctx.fillRect(0,0,MAP_W,MAP_H);
  ctx.strokeStyle = "#1a1f2e";
  ctx.lineWidth = 1;
  for (let x=0; x<MAP_W; x+=80) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,MAP_H); ctx.stroke(); }
  for (let y=0; y<MAP_H; y+=80) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(MAP_W,y); ctx.stroke(); }

  // Optional: draw spawn points
  ctx.fillStyle = "#2a334f";
  for (const s of spawnPoints) {
    ctx.beginPath(); ctx.arc(s.x, s.y, 6, 0, Math.PI*2); ctx.fill();
  }

  // Player safe radius during protection
  const now = performance.now();
  if (now <= (player.spawnSafeUntil || 0)) {
    ctx.beginPath();
    ctx.arc(player.pos.x, player.pos.y, SAFE_RADIUS, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(138,164,255,0.35)";
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  // Player
  ctx.beginPath();
  ctx.arc(player.pos.x, player.pos.y, PLAYER_RADIUS, 0, Math.PI*2);
  ctx.fillStyle = "#8aa4ff";
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#dfe5f4";
  ctx.stroke();

  // Cops
  for (const cop of cops) {
    ctx.beginPath();
    ctx.arc(cop.pos.x, cop.pos.y, COP_RADIUS, 0, Math.PI*2);
    ctx.fillStyle = "#ff9aa2";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#ffd1d6";
    ctx.stroke();
  }

  // Countdown 3-2-1-GO
  const t = (player.uiCountdownEnd || 0) - now;
  if (t > -200) { // show GO for 0.2s
    const s = Math.ceil(Math.max(0, t) / 1000); // 3..2..1..0
    const text = (t > 0) ? (s.toString()) : "GO!";
    ctx.save();
    ctx.globalAlpha = 0.94;
    ctx.font = "900 64px Inter, system-ui";
    ctx.textAlign = "center";
    ctx.fillStyle = "#eaeaf0";
    ctx.fillText(text, player.pos.x, player.pos.y - 48);
    ctx.restore();
  }

  ctx.restore();
}

/* =========================
   === Boot & Main Loop  ===
   ========================= */
function gameLoop() {
  const now = performance.now();
  const dt = Math.min(0.033, (now - last) / 1000); // clamp dt
  last = now;

  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// Start wanted instantly but give spawn protection
respawnPlayer();

// Seed a few initial cops (respecting safe radius)
for (let i=0; i<4; i++) spawnCopAvoidingPlayer(randPos(), player);

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
